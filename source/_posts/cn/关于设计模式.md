---
title: 常见单例模式五种设计方式
catalog: true
date: 2022-04-17 02:34:17
subtitle: 
lang: cn
header-img: /img/header_img/lml_bg.jpg
tags:
- 设计模式
categories:
- 设计模式
---
#### 常见单例模式五种设计方式：

##### 1.饿汉式（相对于懒汉式）

###### 饿汉即没有调用getIntance时就已经创建了对象了，因为是静态的被初始化了

构造方法必须是私有的，除了本类不能调用；

提供一个静态的成员变量，值为用私有构造出创建的对象；

提供一个静态的方法getIntance用来返回静态实例，每一次调用该方法都是得到的同一对象



注意问题：静态块和变量在加载的时候就会执行和初始化，所以像下面的代码，在加载INSTANCE变量时会进行new Singleton，所以会调用构造方法，之后再进行调用main方法

```java
package com.company;

import java.io.Serializable;

//饿汉式
public class Singleton implements Serializable {
    private Singleton() {
        System.out.println("private Singleton()构造");
    }

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance(){
        return INSTANCE;
    }

    public static void otherMethod() {
		System.out.println("OtherMethod()执行");
    }
}

```

但是上面的单例模式会被三种方式破坏：

1.反射破坏

解决：在构造方法执行代码前加入条件判断

```java
if(INSTANCE != null){
    throw new RuntimeException("对象已创建");
}
sout("正常创建！");
```

2.反序列化破坏 

解决：在Singleton类中加一个方法,反序列化时检测到该方法被重写，就会执行并返回INSTANCE而不是新对象

```java
public Object readResolve(){
    return INSTANCE;
}
```

3.Unsafe类破坏（未解决）

##### 2.枚举饿汉类

```java
package com.company;
//枚举饿汉
public enum Singleton2 {
    INSTANCE;
    private Singleton2(){
        System.out.println("private Singleton()");
    }
    public String toString(){
        return getClass().getName()+"@"+Integer.toHexString(hashCode());
    }
    public static Singleton2 getInstance(){
        return INSTANCE;
    }
    public static void otherMethod(){
        System.out.println("otherMethod()");
    }
}

```



枚举在底层已经解决了反射和反序列化破坏（没解决safe）

##### 3.懒汉式（synchronized性能太低）

```java
package com.company;

public class Singleton3 {
    private Singleton3(){
        System.out.println("private ()");
    }
    private static Singleton3 INSTANCE  = null;
    //直接在创建实例的方法上进行加锁，避免多线程并发重复创建
    public static synchronized Singleton3 getInstance(){
        if(INSTANCE != null){
            INSTANCE  = new Singleton3();
        }
        return INSTANCE;
    }
    public static void otherMethod(){
        System.out.println("otherMEthod()");
    }
}

```

4.DCL懒汉（双检锁懒汉）

不需要每一次检测都要加锁，只需要在并发情况下第一次创建对象的时候进行加锁

一定要进行两次if判断，外面是为了创建完对象之后不在进入同步块中

```java
package com.company;
//DCL懒汉
public class Singleton4 {
    private Singleton4(){
        System.out.println("private ()");
    }
    private static volatile Singleton4 INSTANCE  = new Singleton4();
    public static Singleton4 getInstance(){
        if (INSTANCE != null){
            //直接锁的类对象
            synchronized (Singleton4.class){
                if(INSTANCE != null){
                    INSTANCE = new Singleton4();
                }
            }
        }
        return INSTANCE;
    }
}

```

PS：DCL懒汉创建出的对象必须被volatile修饰，这里是为了保证有序性，不然多线程下会导致创建对象、连接引用指令和if判断之间的错误，不然还是会出现重复创建对象

#### 推荐：5、内部类懒汉式

在单例对象类内部创建静态内部类

```java
package com.company;
//最终版
public class Singleton5 {
    private Singleton5(){
        System.out.println("private ()");
    }
    public static class Holder{
        static Singleton5 INSTANCE = new Singleton5();
    }
    public static Singleton5 getInstance(){
        return Holder.INSTANCE;
    }
    public  static void otheMethod(){
        System.out.println("otherMethod()");
    }
}

```

既保留了懒汉的优良特性，又保证不会出现线程安全破坏单例的问题



