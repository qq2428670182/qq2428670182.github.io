---
title: 关于JVM
catalog: true
date: 2022-04-05 02:34:17
subtitle: 
lang: cn
header-img: /img/header_img/lml_bg.jpg
tags:
- JVM
categories:
- JVM
---

JVM内存结构

![JVM内存结构图](Snipaste_2022-04-20_14-48-49.png)

先将java代码转换为java字节码，然后通过类加载的机制将字节码加载到内存中的方法区中，执行中类的加载类似于懒加载（延迟加载），即只有当线程执行时调用到了没有的类才会通过双亲委派区查找需要的类去加载，由类new出来的成员对象存储在JVM内存的堆中，而局部变量和方法参数等占用的内存在虚拟机栈中，一个线程一个栈（比如main）

方法分为两类：一类是普通的java方法，另一类是java借助于操作系统实现的方法，第二种叫做本地方法，存储的位置是本地方法栈，和普通方法位置不一样，这只是约定俗成，实际存储都是在一个统一的栈中，只不过可以细分。

程序计数器用来记录当前线程进行到哪一行代码，栈和程序计数器属于线程，解决比如线程上下文切换

在执行引擎上，解释器解释字节码为机器码，而对于热点代码用即时编译器进行编译后放入缓存中，不需要每次都进行解释执行

#### 类加载的顺序：

先执行父类的静态块、静态变量（按语句顺序进行加载），再加载子类的静态块和变量，注意这里的加载是将代码片段加载到方法区中但没有执行，所有的方法不管是否静态都要被调用才会执行，只有静态块是不受调用就可执行的，只不过静态资源已经提前加载好了，当方法中调用了其他类或者调用了非静态成员或方法，才开始加载需要的类。

加载父类的实例成员和代码块，再执行父类的构造方法，再加载子类的实例成员和代码块，最后才调用子类的构造方法来创建对象（注意加载非静态的代码必须在被调用或创建时才会被加载，不调用不加载）

要创建某个类的对象，要先干完所有静态的活，最后再调用构造方法，如果需要在main方法调用之前就执行一些语句，只能把它放在static块中，main方法的执行顺序是在静态块和变量初始化完之后，JVM进行调用main，main中有其他需要的类，才产生了被需要类实例对象方法和构造方法的加载与执行。

#### 内存溢出：

除了程序计数器之外，都有可能产生内存溢出（主要是变成失误）

OutofmemoryError:

堆内存耗尽：对象越来越多，且不能被垃圾回收

方法区内存耗尽：加载的类越来越多，或者在运行中加载的越来越多。

虚拟机栈累计：每个线程最大占用1m内存，线程越来越多又不销毁

StackOverFlowError

栈内部方法调用次数过多（比如循环调用死循环了），是在一个线程内的栈满了



#### 方法区，永久代，元空间：

方法区是JVM规范定义的一块内存，而永久代是HOTSpot虚拟机对JVm规范的一种实现1.8之前的，1.8之后的实现是元空间，元空间中存储的才是类的元数据，在加载类的时候，会将类的元数据加载到元空间中，会在堆中生成类的Class对象，通过class对象反射引用元空间中的元数据来完成new实例对象等操作，当实例对象或class对象均不被引用时，当垃圾回收时将无用的对象进行回收，此时仍不会将元数据进行卸载，当类加载器被销毁的时候，才会把类加载器以前加载过的对应的类的元数据进行删除（当然一般是自定义的类加载器被销毁）

#### JVM常用参数：

（图上标出的Ratio是默认比例）（默认单位都是兆比特即mb简写为m）

![JVM常用参数](Snipaste_2022-04-20_17-31-23.png)

-Xmx：最大堆的限制大小

-Xms：初始的堆的大小

-Xmn：年轻代所分配空间大小

-XX:survivorRatio,-XX后面跟的都是内存设置参数，例如该参数代表伊甸园：幸存者（from或to也就是一半）是几比几，from和to的比例始终是一比一

JVM堆内存分为新生代和老年代（当然还有未分配的保留空间）

新生代又分为：	eden伊甸园		survivor幸存者 （幸存者又分为from和to）

标记清除：直接对不需要的对象进行内存清除，会产生内存碎片

标记整理：在清除的基础上进行改进，对剩余未清理的内存进行整理，增大可利用的连续空间（减少内存碎片）

标记复制：空对象清理之后，将未清理的内存放入到to内存区中，每一次复制完之后，from和to区进行交换（名义上进行交换），标记复制的速度比标记整理要快，仅需复制到新空间之后直接把旧空间清空即可，但是需要开辟一块额外的空间，占用内存

当对象在幸存者区一定清理次数后，可以升级为老年代（最少为15次，但是大对象和新生代空间紧张可以提前）



方法区在逻辑上是独立的，但是在物理上还是一片共享的区域，可以说是堆内存，但是方法区又叫非堆，用来明确和堆的区别，在逻辑上且JDK1.7及之前，（持久代）永久代是方法区的一片区域，其中包括运行时常量池和字符串常量池等，运行时常量池里存储着字面值，变量，代码片段（.class文件）等等，1.8之后变为元空间，元空间是方法区的实现，里面存储着class字节码文件，程序执行时会动态从元空间中映射相应的代码去执行，在类加载时代码片段被加载到元空间中，直到虚拟机关闭元空间才卸载代码片段。

##### finalize和GC

当Object失去GCROOTS的引用链时，会进行第一次标记，然后判断Object的finalize方法是否被重写或被执行过一次，注意finalize也只能被执行一次，所以只有一次复活的机会，如果满足上述条件，就会将Object放入队列F-Queue，由低优先级线程进行执行Queue中对象的finalize方法，执行完之后判断此时是否可达（即判断是是否有复活的机会），若可达则将对象移出即将被回收的内存，不可达则进行第二次标记，被第二次标记的对象会在下一次GC的时候被回收

###### 如果在第一次标记后发现没有重写finalize或者对象的finalize已经被执行（后者说明该对象曾经被复活过一次），那么直接将该对象二次标记，等待GC

> 扩展：final关键字

> 引用（变量）被final修饰时，该引用不能再改变，即不能执行其他的对象（即只想地址不可变），但是只想地址的对象的内容是可变的，所以可以用其他的变量去修改final对象的值



#### JDK自带命令行工具

jps：查看正在运行的java虚拟机进程

jstat：查看虚拟机运行时信息

jstack：查看虚拟机运行时刻栈的线程快照信息

jmap：查看或导出堆的快照信息

jhat：JDK自带的堆分析工具

jinfo：实时查看和调整JVM的各项参数



