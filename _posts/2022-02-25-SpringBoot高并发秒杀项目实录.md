---
layout: post
title: 'SpringBoot高并发秒杀'
date: 2022-02-25
author: Futari
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: SpringBoot RabbitMQ Redis
---
实现高性能、一致性、高可用	

前端进行一次md5加密，传输过程中再进行一次加密，提高安全程度

利用逆向工程由数据库表和模板来生成对应的实体类、接口、实现类等等，需要的保留，不需要的在后续中删除

开发登陆功能是为了为后续的秒杀功能提供鉴权，只有用户才能进行秒杀

登陆页面中校验和前端的返回值不再使用return返回数据枚举或常量类，而是抛出异常来被ControllerAdvice捕获，进行统一的异常处理，为了程序的健壮性，减少service中的service校验代码，直接使用Valication框架，基本规则通过已定义的注解限定变量，自定义的校验规则使用自定义注解设定默认规则和@Constraint(validatedBy = {.class})来指定规则类来实现

Nginx 使用默认负载均衡策略（轮询），请求将会按照时间顺序逐一分发到后端应用上。

所以需要解决分布式Session问题（多个Tomcat用SpringSession或redis实现session的同步）

不再使用多个tomcat去存储session，而是使用一个独立的redis存储



#### 秒杀相关问题

页面缓存：并发的问题主要存在于数据库，所以要尽量减少对数据库的访问，所以可以加缓存，除了页面缓存之外，还有对象缓存、URl缓存等等

页面不需要系统整个的来生成页面同时整个页面地传输，减少流量，改为从缓存中取html取页面，取不到页面（缓存过时间失效了）的话就在后端执行生成并保存到redis，一般对缓存设置一个失效时间，因为缓存也不是一直能用的，除非数据根本不会变，那样推荐直接页面静态化，URL静态化是指多页面情况下，比如通过id来确定访问某一个id的页面。一般适用于更改数据比较频繁的页面，所以失效时间不能太长。

页面静态化：通过直接访问纯HTml来减少对服务器的请求以及减少数据在网络中的传输，比如动态页面优化后，改用vue或其他的方式只传输页面中需要变化的数据部分，来实现前后端分离，这样还不能说是完全的页面静态化，完全的使用html才是页面静态化，一般静态化应用于更改很少的页面，当改变数据时的同时调用静态化。

##### 秒杀存在的问题：超卖问题，一个用户在高并发请求下多次秒杀，库存减少数和订单生成数不一致

解决方法：

超卖：在减少库存的sql语句上同时判断库存是否为0，如果为0不满足sql条件，所以减库存sql不能被执行

库存减少数和订单生成数不一致：库存减少语句生成boolean值，true才能生成一条order

一个用户在高并发请求下多次秒杀：数据库表添加索引，就是分表，秒杀的订单和正常的订单是两张表，在数据库中建立用户id和商品id的唯一索引，防止用户插入重复的记录。

每次插入的时候，索引不能重复就不能插入，因为写了事务的注解 就会回滚。

还可以将订单插入到缓存中。







将数据库访问加入到redis中，继续优化：也并不是将所有请求都交给redis，而是设置队列依次执行，在用户端提供一个队列等待的友好提示，用队列解决高并发的问题

##### RabbitMQ四种交换机（六种模式）：

simple简单模式：work quene，一个生产者对应多个消费者，但是一个消息只能有一个消费者

Fanout:广播模式也叫订阅者发布者模式，直接指定队列和交换机，不需要routingkey（路由键）

Direct：直连模式也叫rouing路由模式，在基本模式上加上routingkey来指定具体进入哪一个队列，queue由它对应的路由键

Topic:主题模式

Headers(用的少):头部交换机

RPC模式

